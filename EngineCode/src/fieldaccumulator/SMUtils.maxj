package fieldaccumulator;

import com.maxeler.maxcompiler.v2.errors.MaxCompilerAPIError;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmSliceableVariable;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.StateMachineLib;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmTypeFactory;

public class SMUtils {

  /**
   * Byte Index
   */
  public static int B(int index) {
    return index*8;
  }

  /**
   * Word Index
   */
  public static int W(int index) {
    return B(index*2);
  }

  /**
   * Index is of the byte
   */
  public static DFEsmValue extractByte(DFEsmValue v, int byteIndex) {
    return extractBytes(v, byteIndex, byteIndex);
  }

  /**
   * Indices are in bytes
   */
  public static DFEsmValue extractBytes(DFEsmValue v, int highByteIndex, int lowByteIndex) {
    return v[B(highByteIndex+1)-1:B(lowByteIndex)];
  }


  public static long htonl(int n32) {
    long n = n32;
    long r = 0;
    r = (n << 16 & 0xFFFF0000L) | (n >> 16 & 0x0000FFFFL);
    r = (r << 8  & 0xFF00FF00L) | (r >> 8  & 0x00FF00FFL);
    return r & 0xFFFFFFFF;
  }

  public static int htons(int n16) {
    int n = n16;
    int r = 0;
    r = (n << 8  & 0xFF00) | (n >> 8  & 0x00FF);
    return r & 0xFFFF;
  }

  public static DFEsmValue byteReverse(DFEsmValue v) {
    int lengthBytes = v.getType().getTotalBits() / 8;
    DFEsmValue newV = v[B(1)-1:B(0)];
    for (int i=1; i < lengthBytes; i++) {
      newV = newV # v[B(i+1)-1:B(i)];
    }
    return newV;
  }

  /**
   * index is of the word
   */
  public static DFEsmValue extractWord(DFEsmValue v, int wordIndex) {
    return v[W(wordIndex+1)-1:W(wordIndex)];
  }

  /**
   * Indices are in words
   */
  public static DFEsmValue extractWords(DFEsmValue v, int highWordIndex, int lowWordIndex) {
    return v[W(highWordIndex+1)-1:W(lowWordIndex)];
  }


  /**
   * Sums up Words (16 bit) values, optional byte swap before sum.
   * Useful for checksum calculations
   */
  public static DFEsmValue sum16(DFEsmValue v, boolean byteSwap) {
    int numWords = v.getType().getTotalBits() / 16;
    if (v.getType().getTotalBits() % 16 != 0) {
      throw new MaxCompilerAPIError("Can only process complete 16-bit words. Not %d bits.", v.getType().getTotalBits());
    }
    DFEsmValue sum;
    if (byteSwap) {
      sum = (v[B(1)-1:B(0)] # v[B(2) - 1: B(1)]).cast(DFEsmTypeFactory.dfeUInt(32));
    } else {
      sum = v[B(2) - 1: B(0)].cast(DFEsmTypeFactory.dfeUInt(32));
    }
    for (int i = 1; i < numWords; i++) {
      if (byteSwap) {
        sum = sum + (v[B(2*i + 1) - 1: B(2*i)] # v[B(2*i + 2) - 1: B(2*i + 1)]).cast(DFEsmTypeFactory.dfeUInt(32));
      } else {
        sum = sum + v[B(2*i + 2) - 1: B(2*i)].cast(DFEsmTypeFactory.dfeUInt(32));
      }
    }
    return sum;
  }

  public static DFEsmValue sum16(DFEsmValue v) {
    return sum16(v, false);
  }

  public static DFEsmValue replaceBit(DFEsmValue src, int bitOffset, DFEsmValue newBit) {
    if (newBit.getType().getTotalBits() > 1)
      throw new MaxCompilerAPIError("new Bit is %d bits wide. not 1.", newBit.getType().getTotalBits());
    return replaceValue(src, bitOffset, newBit);
  }

  /**
   * Replaces a field in 'src' at bit offset 'offset' with 'newValue'  *
   *
   */
  public static DFEsmValue replaceValue(DFEsmValue src, int bitOffset, DFEsmValue newValue) {
    int width = src.getType().getTotalBits();
    int fieldWidth = newValue.getType().getTotalBits();

    if (width - (bitOffset + fieldWidth) < 0)
      throw new MaxCompilerAPIError("new width will exceed source width: Source width %d, offset: %d, new Value width: %d",
          width, bitOffset, fieldWidth);

    // Replace the whole field
    if (width == fieldWidth && bitOffset == 0)
      return newValue;

    if (bitOffset > 0 && width-1 > (bitOffset+fieldWidth-1)) // middle bit
      return src[width-1:bitOffset+fieldWidth] # newValue # src[bitOffset-1:0];
    else if (bitOffset > 0) // left most bit
      return newValue # src[bitOffset-1:0];
    else if (width-1 > bitOffset) // right most bit
      return src[width-1:fieldWidth] # newValue;
    else // single bit
      return newValue;
  }

  public static DFEsmValue replaceField(DFEsmValue src, DFEStructType struct, String fieldName, DFEsmValue newValue) {
    return replaceValue(src, struct.getPositionForField(fieldName), newValue);
  }

  public static DFEsmValue extractField(DFEsmValue src, DFEStructType struct, String fieldName) {
    return src.slice(struct.getPositionForField(fieldName), struct.getTypeForField(fieldName).getTotalBits());
  }

  public static void assignField(DFEsmSliceableVariable dst, DFEStructType struct, String fieldName, DFEsmValue v) {
    dst[struct.getPositionForField(fieldName) + struct.getTypeForField(fieldName).getTotalBits() - 1: struct.getPositionForField(fieldName)].connect(v);
  }

  public static void assignField(DFEsmSliceableVariable dst, DFEStructType struct, String fieldName, int v) {
    dst[struct.getPositionForField(fieldName) + struct.getTypeForField(fieldName).getTotalBits() - 1: struct.getPositionForField(fieldName)].connect(v);
  }

  public static void assignField(DFEsmSliceableVariable dst, DFEStructType struct, String fieldName, boolean v) {
    dst[struct.getPositionForField(fieldName) + struct.getTypeForField(fieldName).getTotalBits() - 1: struct.getPositionForField(fieldName)].connect(v);
  }

  public static void assignBytes(DFEsmSliceableVariable dst, int high, int low, DFEsmValue val) {
    dst[SMUtils.B(high+1)-1:SMUtils.B(low)] <== val;
  }

  public static void assignByte(DFEsmSliceableVariable dst, int ix, DFEsmValue val) {
    assignBytes(dst, ix, ix, val);
  }

  public static void assignBytes(StateMachineLib owner, DFEsmSliceableVariable dst, int high, int low, long val) {
    dst[SMUtils.B(high+1)-1:SMUtils.B(low)] <== owner.constant.value(DFEsmTypeFactory.dfeUInt(SMUtils.B(1+high-low)), val);
  }

  public static void assignByte(StateMachineLib owner, DFEsmSliceableVariable dst, int ix, long val) {
    assignBytes(owner, dst, ix, ix, val);
  }

  public static DFEsmValue rotateLeft(DFEsmValue dst, int byIndex) {
    int total = dst.getType().getTotalBits();
    if (byIndex == 0)
      return dst;
    else if (total > byIndex)
      return dst[total-byIndex-1:0] # dst[total-1:total-byIndex];
    else
      return rotateLeft(dst, byIndex % total);
  }

  public static DFEsmValue shiftLeft(StateMachineLib owner, DFEsmValue dst, int by) {
    int total = dst.getType().getTotalBits();
    if (by == 0)
      return dst;
    else if (by >= total)
      return owner.constant.value(dst.getType(), 0);
    else
      return dst[total-by-1:0] # owner.constant.value(DFEsmTypeFactory.dfeUInt(by), 0);
  }

  public static DFEsmValue shiftRight(StateMachineLib owner, DFEsmValue dst, int by) {
    int total = dst.getType().getTotalBits();
    if (by == 0)
      return dst;
    else if (by >= total)
      return owner.constant.value(dst.getType(), 0);
    else
      return owner.constant.value(DFEsmTypeFactory.dfeUInt(by), 0) # dst[total-1:by];
  }
}
